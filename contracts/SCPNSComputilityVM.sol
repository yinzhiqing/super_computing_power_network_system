// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

import "./SCPNSBase.sol";
import "./interface/ISCPNSComputilityUnit.sol";
import "./interface/ISCPNSComputilityVM.sol";
import "./PairValues.sol";


contract SCPNSComputilityVM is
   SCPNSBase,
   ISCPNSComputilityVM 
   {
     using CountersUpgradeable for CountersUpgradeable.Counter;
     using PairValues for PairValues.PairUint256;
     

     address public computilityUnitAddr;
     ISCPNSComputilityUnit internal _computilityUnitIf;

     // Mapping from id to user 
     mapping (uint256 => address) private _users;
     // Mapping from id to deadline
     mapping (uint256 => uint256) private _deadlines;
     // Mapping from id to computility units list
     mapping (uint256 => PairValues.PairUint256) private _tokenComputilityUnits;

    function initialize(address computilityUnitAddr_) public virtual initializer {
        __SCPNSBase_init("SCPNSComputilityVM", "SCPNSComputilityVM", "");
        __SCPNSComputilityVM_init(computilityUnitAddr_);
    }
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     */
    function __SCPNSComputilityVM_init(address contract_) internal initializer {
        __SCPNSComputilityVM_init_unchained(contract_);
    }

    function __SCPNSComputilityVM_init_unchained(address contract_) internal initializer {
        _unitType("computilityvm");
        computilityUnitAddr = contract_;
        _computilityUnitIf = ISCPNSComputilityUnit(contract_);
    }

    function mint(address to, uint256 tokenId, uint256 deadline,
                  uint256[] memory computilityUnits, uint256[] memory typeUnitCounts, string memory datas) public virtual override {
        require(computilityUnits.length == typeUnitCounts.length, "SCPNSComputilityVM: computilityUnits and typeUnitCounts length is differ");
        require(deadline > block.timestamp, "SCPNSComputilityVM: deadline is too small.");

        _mint(to, tokenId, bytes32(tokenId), datas);

        uint256 len = computilityUnits.length;
        for (uint256 i = 0; i < len; i++) {
            _tokenComputilityUnits[tokenId].sets(computilityUnits, typeUnitCounts);

            _computilityUnitIf.lockResources(computilityUnits[i], typeUnitCounts[i]);
        }

        _deadlines[tokenId] = deadline;
    }

    function changeUser(address to, uint256 tokenId) public virtual override {
        require(_msgSender() == super.ownerOf(tokenId), "SCPNSComputilityVM: only owner of token can change user");
        require(to != address(0), "SCPNSComputilityVM: new user address is address(0)");
        require(!_exists(tokenId), "SCPNS: token is nonexists.");

        _users[tokenId] = to;
    }

     uint256[48] private __gap;
   }


