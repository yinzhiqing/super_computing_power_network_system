// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "./SCPNSBase.sol";
import "./interface/ISCPNSTypeUnit.sol";

/**
 * @dev {SCPNSTypeUnit} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract SCPNSTypeUnit is 
    SCPNSBase,
    ISCPNSTypeUnit
    {
    // Maping from comptility id to unit(gpu/memory) id 
    mapping (uint256 => uint256) internal _id2UnitIds;
    // Maping from unit id to unit address
    mapping (uint256 => address) internal _unitId2UnitAddr;
    // Maping from typename to id
    mapping (address => bool) internal _validUnitTypes;

    address[] internal _allUnitTypes;

    function initialize() public virtual initializer {
        __SCPNSBase_init("SCPNSTypeUnit", "SCPNSTypeUnit", "");
        __SCPNSTypeUnit_init();
    }
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     */
    function __SCPNSTypeUnit_init() internal initializer {
        __SCPNSTypeUnit_init_unchained();
    }

    function __SCPNSTypeUnit_init_unchained() internal initializer {
        _unitType("types");
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be tokenId
     * URI autogenerated based on the base URI passed at construction.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint256 tokenId, bytes32 name_, address unitAddr, uint256 unitId, string memory datas) public virtual override {
        require(_validUnitTypes[unitAddr], "SCPNSTypeUnit: unitAddr is not existed.");

        _mint(to, tokenId, name_, datas);
        _id2UnitIds[tokenId] = unitId;
        _unitId2UnitAddr[unitId] = unitAddr;
    }

    function addUnitType(address unitAddr) public virtual {
        require(hasRole(MANAGE_ROLE, _msgSender()), "SCPNSTypeUnit: must have manager role to add");
        require(unitAddr != address(0), "SCPNSTypeUnit: unitAddr is invalid address.");
        _validUnitTypes[unitAddr] = true;

        _allUnitTypes.push(unitAddr);
    }

    function removeUnitType(address unitAddr) public virtual {
        require(hasRole(MANAGE_ROLE, _msgSender()), "SCPNSTypeUnit: must have manager role to remove");
        if (_validUnitTypes[unitAddr]) {
            delete _validUnitTypes[unitAddr];
        }
    }

    function isValidUnitType(address unitAddr) public view returns(bool) {
        return _validUnitTypes[unitAddr];
    }

    function _burn(uint256 tokenId) internal virtual override(SCPNSBase) {
        super.burn(tokenId);
        delete _id2UnitIds[tokenId];
    }

    function unitTypeOf(uint256 tokenId) public view override returns(string memory) {
        address unitAddr = _unitId2UnitAddr[tokenId];
        if (unitAddr != address(0) && _validUnitTypes[unitAddr]) {
           ISCPNSTypeUnit iuf = ISCPNSTypeUnit(unitAddr);
           return iuf.unitType();
        }
        return "";
    }

    uint256[48] private __gap;
}
