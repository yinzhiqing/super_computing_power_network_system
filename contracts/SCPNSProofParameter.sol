// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

import "./SCPNSBase.sol";
import "./interfaces/ISCPNSTypeUnit.sol";
import "./interfaces/ISCPNSProofParameter.sol";
import "./ContractProject.sol";
import "./PairValues.sol";

/**
 * @dev {SCPNSProofParameter} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract SCPNSProofParameter is 
    SCPNSBase,
    ContractProject,
    ISCPNSProofParameter
    {
    using CountersUpgradeable for CountersUpgradeable.Counter;
    using PairValues for PairValues.PairUint256;

    // Mapping from id to parameter list
    mapping (uint256 => string) private _id2Parameters;
    // Mapping from id to parameter parse(name : value)
    mapping (uint256 => mapping(string => uint256)) private _id2ParametersParse;
    // Mapping typeUnitId to rate of per
    mapping (uint256 => uint256) private _typeUnitRate;
    // Mapping from id to min second of typeUnitId
    mapping (uint256 => mapping(uint256 => uint256)) _id2MinOfTypeUnit;
    // Mapping from id to max second of typeUnitId
    mapping (uint256 => mapping(uint256 => uint256)) _id2MaxOfTypeUnit;
    // Mapping from typeUnitId to id
    PairValues.PairUint256 private _typeUnitId2defaultIds;

    function initialize(address dns) public virtual initializer {
        __SCPNSBase_init("SCPNSProofParameter", "SCPNSProofParameter", "");
        __ContractProject_init(dns);
        __SCPNSProofParameter_init();
    }
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     */
    function __SCPNSProofParameter_init() internal initializer {
        __SCPNSProofParameter_init_unchained();
    }

    function __SCPNSProofParameter_init_unchained() internal initializer {
        _unitType("types");
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be tokenId
     * URI autogenerated based on the base URI passed at construction.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(uint256 tokenId, bytes32 name_, string memory parameter, string[] memory pnames, uint256[] memory pvalues, string memory datas) public virtual override whenNotPaused {
        require(bytes(parameter).length > 0,  
                "SCPNSProofParameter: parameter is empty");

        require(pnames.length == pvalues.length,
               "SCPNSProofParameter: panmes and pvalue is non-match");

        _mint(_msgSender(), tokenId, name_, datas);

        _id2Parameters[tokenId] = parameter;
        for(uint256 i = 0; i < pnames.length; i++) {
            _id2ParametersParse[tokenId][pnames[i]] = pvalues[i];
        }
    }


    function setDefaultTokenOf(uint256 typeUnitId, uint256 tokenId) public virtual override whenNotPaused {
        require(hasRole(MANAGER_ROLE, _msgSender()) || _msgSender() == super.ownerOf(tokenId), 
                "SCPNSBase: must have manager role");
        require(_exists(tokenId), "SCPNSProofParameter: token is nonexists");
        require(_typeUnitIf().exists(typeUnitId), "SCPNSProofParameter: typeUnitId is nonexists");

        _typeUnitId2defaultIds.set(typeUnitId, tokenId);
    }

    function typeUnitIds() public view virtual override returns(uint256[] memory) {
        return _typeUnitId2defaultIds.keysOf();
    }

    function setComputilityRange(uint256 tokenId, uint256 typeUnitId, uint256 min, uint256 max) public virtual override whenNotPaused {
        require(hasRole(MANAGER_ROLE, _msgSender()) || _msgSender() == super.ownerOf(tokenId), 
                "SCPNSBase: must have manager role");
        require(_exists(tokenId), 
                "SCPNSProofParameter: token is nonexists.");
        require(_typeUnitIf().exists(typeUnitId), 
                "SCPNSProofParameter: typeUnitId is nonexists");
        require(min <= max, 
                "SCPNSProofParameter:  min must be less than or equal to max");

        _id2MinOfTypeUnit[tokenId][typeUnitId] = min;
        _id2MaxOfTypeUnit[tokenId][typeUnitId] = max;

    }

    function parameterOf(uint256 tokenId) public view override returns(string memory) {
        return _id2Parameters[tokenId];
    }

    function valueOf(uint256 tokenId, string memory name) public view virtual override returns(uint256)
    {
        return _id2ParametersParse[tokenId][name];
    }

    function parameterIdOfTypeUnitId(uint256 typeUnitId) public view virtual override returns(uint256) {
        require(_typeUnitId2defaultIds.exists(typeUnitId), 
                "SCPNSProofParameter: typeUnitId is nonexists");

        return _typeUnitId2defaultIds.valueOf(typeUnitId);
    }

    function computilityRangeOfTypeUnit(uint256 tokenId, uint256 typeUnitId) public view virtual override returns(uint256 min, uint256 max) {
        require(_exists(tokenId), 
                "SCPNSProofParameter: token is nonexists.");
        require(_typeUnitIf().exists(typeUnitId), 
                "SCPNSProofParameter: typeUnitId is nonexists");

        min = _id2MinOfTypeUnit[tokenId][typeUnitId];
        max = _id2MaxOfTypeUnit[tokenId][typeUnitId];
    }

    function sampleOf(uint256 tokenId) public view virtual override returns(uint256) {
        return _id2ParametersParse[tokenId]["sample"];
    }

    function leafCountOf(uint256 tokenId) public view virtual override returns(uint256) {
        return _id2ParametersParse[tokenId]["leaf_count"];
    }

    function leafDeepOf(uint256 tokenId) public view virtual override returns(uint256) {
        return _id2ParametersParse[tokenId]["leaf_deep"];
    }
    function _burn(uint256 tokenId) internal virtual override(SCPNSBase) {
        require(false, 
                "SCPNSProofParameter: can't burn anyone token");
        require(_exists(tokenId), 
                "SCPNSProofParameter: token is noexists");
    }

    uint256[48] private __gap;
}
