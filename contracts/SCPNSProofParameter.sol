// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "./SCPNSUnitBase.sol";
import "./interface/ISCPNSUint.sol";

/**
 * @dev {SCPNSProofParameter} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract SCPNSProofParameter is 
    SCPNSUnitBase
    {
    using CountersUpgradeable for CountersUpgradeable.Counter;
    // typeUnit contract address 
    address public typeUnitAddr;
    // Mapping from id to parameter list
    mapping (uint256 => mapping(bytes32 => uint256)) internal _id2Parameters;
    // Mapping from id to parameter name list
    mapping (uint256 => mapping(uint256 => bytes32)) internal _id2ParameterNames;
    // Mapping from id to parameter name count
    mapping (uint256 => CountersUpgradeable.Counter) internal _id2ParameterCount;
    // Mapping from id to typeUnitId
    mapping (uint256 => uint256) internal _id2TypeUnitId;
    // Mapping from typeUnitId to id
    mapping (uint256 => uint256) internal _typeUnitId2Id;

    function initialize(address typeUnitAddr_) public virtual initializer {
        __SCPNSUnitBase_init("SCPNSProofParameter", "SCPNSProofParameter", "");
        __SCPNSProofParameter_init(typeUnitAddr_);
    }
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     */
    function __SCPNSProofParameter_init(address typeUnitAddr_) internal initializer {
        __SCPNSProofParameter_init_unchained(typeUnitAddr_);
    }

    function __SCPNSProofParameter_init_unchained(address typeUnitAddr_) internal initializer {
        _unitType("types");
        typeUnitAddr = typeUnitAddr_;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be tokenId
     * URI autogenerated based on the base URI passed at construction.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(uint256 tokenId, bytes32 name_, uint256 typeUnitId, string memory datas) public virtual {
        require(_id2TypeUnitId[tokenId] == uint256(0), "SCPNSProofParameter: tokenId is exists.");
        require(_typeUnitId2Id[typeUnitId] == uint256(0), "SCPNSProofParameter: typeUnitId is exists.");

        _mint(tokenId, name_, datas);
        _id2TypeUnitId[tokenId] = typeUnitId;
        _typeUnitId2Id[typeUnitId] = tokenId;

        UpdateDatas(tokenId, name_, _msgSender(), datas);
    }

    function updateTypeUnitAddr(address typeUnitAddr_) public virtual {
        require(hasRole(MANAGE_ROLE, _msgSender()), "SCPNSProofParameter: must have manager role to add");
        require(typeUnitAddr_ != address(0), "SCPNSProofParameter: typeUnitAddr is invalid address.");

        typeUnitAddr = typeUnitAddr;
    }

    function setValueOfParameter(uint256 tokenId, bytes32 pname, uint256 pvalue) public virtual {
        require(hasRole(MANAGE_ROLE, _msgSender()), "SCPNSProofParameter: must have manager role to remove");
        require(_exist(tokenId), "SCPNSProofParameter: tokenId is not exists.");
        require(pname != bytes32(""), "SCPNSProofParameter: pname is invalid.");

        // mabe is new parameter, check it and add to name list
        if (uint256(0) == _id2Parameters[tokenId][pname]) {
            uint256 index = _id2ParameterCount[tokenId].current();
            while(index > 0) {
                if (_id2ParameterNames[tokenId][index - 1] == pname) {
                    break;
                }
                index = index - 1;
            }
            if (index == 0) {
                _id2ParameterCount[tokenId].increment();
                _id2ParameterNames[tokenId][_id2ParameterCount[tokenId].current()] = pname;
            }
        }

        _id2Parameters[tokenId][pname] = pvalue;
    }

    function valueOfParameter(uint256 tokenId, bytes32 pname) public view returns(uint256) {
        return _id2Parameters[tokenId][pname];
    }

    function typeUnitIdOf(uint256 tokenId) public view returns(uint256) {
        return _id2TypeUnitId[tokenId];
    }

    function tokenIdOfTypeUnitId(uint256 typeUnitId) public view returns(uint256) {
        return _typeUnitId2Id[typeUnitId];
    }

    function parameterCountOf(uint256 tokenId) public view returns(uint256) {
        return _id2ParameterCount[tokenId].current();
    }

    function parameterNameOf(uint256 tokenId, uint256 index) public view virtual returns(bytes32) {
        require(index < _id2ParameterCount[tokenId].current(), "SCPNSProofParameter: index out of bounds.");
        return _id2ParameterNames[tokenId][index];
    }
    
    function burn(uint256 tokenId)
    public
    virtual
    override
    {
        while(_id2ParameterCount[tokenId].current() > 0) {
            _id2ParameterCount[tokenId].decrement();
            delete _id2Parameters[tokenId][_id2ParameterNames[tokenId][_id2ParameterCount[tokenId].current()]];
            delete _id2ParameterNames[tokenId][_id2ParameterCount[tokenId].current()];
        }
        delete _id2ParameterCount[tokenId];

        uint256 typeUnitId = _id2TypeUnitId[tokenId];
        delete _typeUnitId2Id[typeUnitId];

        delete _id2TypeUnitId[tokenId];

        _burn(tokenId);
    }

    uint256[48] private __gap;
}
